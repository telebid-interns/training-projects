use strict;
use warnings;
use sigtrap;
use diagnostics;
use lib './';
use Try::Tiny;
use POSIX qw();
use Fcntl qw();
use Scalar::Util qw(blessed);
use Server qw(Server);
use ErrorHandling qw(assert);
use ImportConfig qw();
use Logger qw();

our $log = Logger::log();
our ($ERROR, $INFO, $WARNING, $DEBUG) = Logger::log_levels();
our %CONFIG = ImportConfig::import_config();

sub start {
    my $server = Server::->new();

    try {
        $server->run();
        1;
    } catch {
        my $exc = $_;
        assert(blessed($exc) eq 'Error');

        $log->error($ERROR, msg => $exc->{msg});
    };

    $server->stop();
}

my $pid = fork();

if (!defined($pid)) {
    die("fork: $!");
}

if (!caller(0)) { # if invoked directly as a program
    if ($pid == 0) { # child process
        # change file mode mask
        # files generated by the web server will be available for everyone to read, write and execute
        my $prev_umask = umask(0);

        if (!defined($prev_umask)) {
            die("umask: $!");
        }

        # create a unique session id
        POSIX::setsid();

        # change current working directory to a place that is guaranteed to be there
        chdir('/') or die("chdir: $!");

        # not just closing STDIN and STDOUT, but also redirecting them to /dev/null
        # so that all files that will be opened don't take STDIN and STDOUT's filehandle ids
        sysopen(my $dev_null_fh, '/dev/null', Fcntl::O_RDWR) or die("sysopen: $!");

        POSIX::dup2(fileno($dev_null_fh), fileno(STDIN)) or die("dup2: $!");
        POSIX::dup2(fileno($dev_null_fh), fileno(STDOUT)) or die("dup2: $!");

        close($dev_null_fh) or die("close: $!");

        start();
    } else {
        exit(0); # status code: OK
    }
}
